---
layout: post
title: "可视化编程的误区"
category: technium
tags: []
---


为了做比较，先来看一个可视化 Python 程序的例子：[Online Python Tutor](http://pythontutor.com/visualize.html)。


使用一下它提供的“阶乘”（factorial）例子，点击 visualize，屏幕上出现两栏，红色的箭头示意代码执行到哪一行，屏幕右侧出现了很多变量和值，点了几下 forward 之后程序输出了 720，至于中间到底发生了什么，我还是一头雾水。


新手不知道栈帧（Stack Frame）是怎么回事，即使是一个 Python 老手也不需要知道，因为它和编程没有关系，调用栈仅仅是编程语言实现“子程序调用“的方法。


下面来看 [Vivid 中阶乘的例子](http://vivid.chengyichao.info/factorial/)。不了解 Lisp 语义的朋友可能看不懂，因此我把它们转化了为以下对话（实际上它们是等价的）：


* 老师：小明，请问 4 的阶乘是多少？
* 小明：报告老师，这个问题太难了，我心算不出。
* 老师：那我问你一个简单的问题，3 的阶乘什么？只要你知道 3 的阶乘，乘上 4 不就是 4 的阶乘吗？你告诉我 3 的阶乘是几啊？ 
* 小明：还是不知道。
* 老师：真笨呀，再问你一个更简单的问题，2 的阶乘是多少？只要你知道 2 的阶乘，也就不难知道 3 的阶乘……那么 2 的阶乘是？
* 小明：这个嘛，你让我看一眼阶乘的定义先……
* 老师：你真是气死我了，好吧，再简单一点，1 的阶乘是多少？只要你知道 1 的阶乘，乘 2 不就是 2 的阶乘吗？
* 小明：书上说 1 的阶乘等于 1。
* 老师：那么 2 的阶乘呢？
* 小明：是 1 的阶乘乘上 2，也就是 2。（切，刚刚自己说的，还问我？）
* 老师：3 的阶乘是？
* 小明：2 的阶乘乘上 3，等于 6。
* 老师：那么……
* 小明： 4 的阶乘是 3 的阶乘乘 4，得 24。
* 老师：小明你都会抢答了。


这是一个隐喻（Metaphor），而且是一个十分漂亮的隐喻，通过这个隐喻我们可以把编程与现实世界联系起来，然后理解编程，学习编程（这个例子展示了递归的概念，其他编程概念同样可以用这种形式呈现）。


Polya 在《怎样解题》指出，好的老师应该对学生循循善诱，问答往往是一种很好的教学形式。当然，这个想法不是我原创的，早在 1974 年的时候 Daniel P. Friedman 就写了一本叫《The Little Lisper》的书，在这本只有 68 页的书中他就使用了这种问答的形式。


可能有人会说，Vivid 只是把程序的执行转换为对话，这是可视化吗？不是。


我们可以这样可视化存储器：


    | 0 | 12 |
    | 1 | 16 |
    | 2 | 17 |
    .....



甚至可以这样可视化 C 语言中的的栈帧：


    | 0xccccccc0 | 局部变量1 |
    | 0xccccccc1 | 局部变量2 |
    | 0xccccccc2 | 返回地址 |
    .....


但即使把存储器画得再逼真，每个 blank 都清晰可见，也没有任何意义。


再举一个例子，假设我们要可视化一棵二叉树，我们可以画成这样(假设用的是 visio 这类图表工具，这里我偷懒)：


        (18)
      /   |  \
    (17) (9)  (21)
     |
    (8)



但其实我们只要这样：

    18
      17
         8
       9
      21

或者这样：


    (18 (17 (8) 9 21))


我们没有任何画图工具，只用了几个空格或括号，就表达出了二叉树，因为这就是一棵二叉树所包含的全部信息量：层次信息加上一些值。


而当我们把 (18 (17 (8) 9 21)) 画成一棵二叉树的时候并没有增加任何信息量。


『可视化编程根本一文不值，不过是因为它可视化了错误的东西。传统的可视化环境可视化了代码和静态结构，但是我们不需要理解它们，我们需要理解代码在做什么。』—— Bret Victor


真正的可视化编程应该把原本程序员看不到的东西显示出来。



《The Little Schemer》把程序做了什么（求值）清晰可见地展现在了读者面前，没有用图像，而是用自然语言，学习者看懂对话，自然就知道代码做了什么。今天很多使用了大量花哨 JavaScript 技术的 Online Tutor 没能做到的事情，Freidman 四十年前就做到了。


如果说有什么美中不足的地方，就是书中的问答不能显示成这样的形式：


    问题1
      问题2
      回答2
    回答2


而是采用了线性排版，所以递归几层之后思路容易乱掉，再一深就返不回去了，用 Douglas Crockford 的说法就是：[so deep that your head is going to pop off](http://www.crockford.com/javascript/little.html)。Vivid 可能弥补了这个问题。


这说明可视化并不是通往“理解程序”的唯一途径，《The Little Schemer》又是怎么做到“易于理解”的呢？有两点：


一是通过大量的例子。


Richard Feynman 在日本讲学时就发现他和那些日本学者最大的区别就是他们喜欢抽象思考，而他喜欢从一个实际的例子入手：


> “很好，那么就举一个例子。”这是我的作风：除非我脑袋里能出现一个具体的例子，然后根据这个特例来演算下去，否则我无法理解他们说的东西。所以很多人一开始时会觉得我反应有点慢，不了解问题所在，因为我问一大堆笨问题，像“阴极是正的还是负的？阴离子是这样的还是那样的？”
>
>
> ……他以为我是一步步地跟着他演算，其实不然。我脑中想的，是他正在分析的理论中某个特定、实际的例子，而根据过去经验和直觉，我很清楚这例子的特性。
>
>
> ……所以，在日本时，除非他们给我一个实际的例子，我没有办法了解或者讨论他们的研究工作，但是大多数人都提不出这样的例子。提得出来的例子往往极为薄弱，用其他更简单的方法就可以解决问题了。


然后从这些例子身上寻找到“同构”。回想一下我们学习数学的过程：当我们看到一个新的、抽象无比的概念时简直就像看到外星人一样，这时我们怎么掌握它？我们从一个简单的例子入手，依葫芦画瓢，看它是怎么工作的，重复两三次以后我们就理解了，但前提是例子本身“有说头”，也就是要能对应到原来的概念上，而且必须”通俗易懂“才行。


当我们要理解“组合数”这个概念，就可以用“子集”的概念进行类比，集合 S 的一个组合通常表示 S 元素的一个无序选择，这个选择的过程可以联想为在集合 S 中寻找子集，子集的概念我们已经有了，于是我们理解了组合数。


理解本质上就是一个寻找“同构”的过程，当我们在陌生概念身上找到已知概念身上的“同构”处时，便可以自己的语言表达出来，也就能够理解它。


而把新老概念连接起来的桥梁正是隐喻。


可视化的意义就在于找到视觉上的同构：改变 x 的大小，圆的大小也会跟着改变，所以 x 是一个变量……但很多可视化工具找到的却是硬件（存储器单元）和编程语言之间的同构，我们又怎么能够指望一个陌生的概念（比如栈帧）来帮助我们理解另一个概念（递归）的？


可视化只是方法，找到同构才是目的。指挥硬件演奏“交响乐”亦不是编程。（Bret 提到编程语言必须提供“抽象”、“重组”机制，因为学习编程就是学习怎么“抽象”。）


而《The Little Schemer》通过对话的隐喻，让学习者找到了编程语言和现实世界之间的“同构”，仿佛一位高人独坐身旁，侃侃而谈。
