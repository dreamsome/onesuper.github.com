---
layout: post
title: "闭包那些事儿"
category:  technium
tags: [functional programming, python, ruby]
---

抽象，抽象！

某日，你在检查你的代码的时候发现很多这样的代码:


{% highlight python %}
def add1(s):
   return s + 1

def add2(s):
    return s + 2

...

def add100(s):
    return s + 100

print add3(4)
print add5(7)
...
print add100(279)
{% endhighlight %}

里面有很多的重复的地方，这是不好的味道，加上你又是 [DRY](http://en.wikipedia.org/wiki/Don't_repeat_yourself) 原则的实践者，所以你准备抽象。好在 Python 是一种可以将函数作为第一类对象（first-class）的语言，于是你打算这样做：

{% highlight python %}
def addn(s):
   def foo(x):
   	return x+s
   return foo

print addn(3)(4)
print addn(5)(7)
...
print add(100)(279)
{% endhighlight %}

你定义了一个名叫 addn 的函数，它接收 s 作为参数，返回一个叫 foo 的函数，这个函数接收 x 作为参数，返回 x+s。一下子，你就把原来的100个函数减少到只有一个！


这个时候你开始考虑给 foo 换一个更优雅的名字，在你的程序中，除了在 addn 里面之外 foo 就不会再有被调用的机会，于是你决定干脆让他匿名，代码就成了下面的样子，一下子又少了两行。

{% highlight python %}
def addn(s):
	return lambda x : x+s
{% endhighlight %}

这一切的好处都只有一个原因——Python 有着对闭包（Closure）的良好支持。虽然我不知道为什么 Python 要支持闭包，但是松本行弘曾表示他所以给 Ruby 添加闭包的功能是为了[向 Lisp 致敬](http://www.artima.com/intv/closures.html)。


### 自由变量

变量有“自由”和“非自由”之分，所谓的“非自由”或“受限”的变量就是指一个函数的输入参数和内部变量，它们在一个函数执行之前就确定了。比如在一个求圆面积的函数中，圆周率 pi 在函数内部分配，而半径已经通过压栈传递给了函数，函数内通过形参 radius 来引用，因此无论在哪个地方，只要调用 circle_area(2)，输出都是唯一的。

{% highlight python %}
def circle_ara(radius):
	pi = 3.14
	area = pi * radius * radius
	return area
{% endhighlight %}

但是在下面这个例子中，函数的输出却不再是绝对的了，它可能随着上下文的变化而变化。

{% highlight python %}
def answer_to_the_universe():
	number = 42
	def tell():
		return number
	return tell

print answer_to_the_universe()() #print 42 on the screen
{% endhighlight %}	
	
 
因为这里的 number 是一个自由变量，它必须随着函数 tell 一起作为 answer\_to\_the\_universe() 的返回值一起返回，否则当 answer\_to\_the_universe() 执行到 return tell 这条语句的时候，number 的生命周期就结束了，等调用到 tell 的时候就永远得不到答案了。


所以自由变量 number 所引用的对象不能释放，所以要把函数定义时的引用环境和函数的代码打包成一个整体，而这就是闭包，当函数被调用时，调用的不仅仅是函数的代码，还有定义时的上下文。


### 闭包的由来


第一次听到“闭包”的人很容易把它和离散数学中的闭包混淆起来，那么，计算机中的闭包和数学上的闭包有什么关系呢？


答案其实是“没有关系”，数学中的闭包指的是运算的封闭，比如实数在加法这种运算上闭合，因为两个实数怎么减都是实数，而不可能出现复数，但是自然数集合在减法运算上就不闭合，因为可能减出负数来。


而在计算机中，闭包 = 函数的代码块 + 函数定义时的引用环境。


事实上 SICP 这本书已经告诉我们了——“Lisp 社团还用术语‘闭包’描述一个与此毫不相干的概念：闭包也是一种表示带有自由变量的过程而用的实现技术。”，显然书中的闭包指的是数学上的闭包。


那么搞 Lisp 的那帮人为什么要用 Closure 这个单词来命名呢？一种可能性就是为了好玩，著名的Lisp程序员Graham给他的公司起名字时居然用了 Y Combinator（数学中用来计算函数不动点的一种高阶函数）。


另一种靠谱的解释就是，闭包的确把自由变量的作用域的“关闭”住了，而没有让它到处乱蹿，试想一下如果我们使用一个全局变量 number，一样也能达到目的，但是这样很不优雅，而且在多重嵌套的时候会发生冲突。


### 应用


闭包最大的好处就是可以从一定程度上对程序进行抽象，尤其是对“循环迭代”的抽象。比如我要对一个数组中所有元素进行一些操作，比如乘 2，至于如何遍历数组，正向也好，逆向也罢，我们并不关心，于是在 Ruby 中，把一个数组中的元素拿出来都乘以 2，只需要一行就够了。

{% highlight python %}
a = [1, 2, 3, 4, 5]
b = a.map { |x| x *= 2 }
print b # print 2, 4, 6, 8, 10 on the screen
{% endhighlight %}

如果这是一个很大的数组，而且它的各个元素分布在全球各地的服务器上，也和我们没关系，我们关注的仍旧是 x * 2 这一小段逻辑，可能在背后是成千上万台服务器得到了我们传过去的这一小段闭包，然后独自完成其中一小部分迭代。这就是 map 和 reduce 的基本思想，而它们最早是 Lisp 中的两个函数。


### 结尾

随着越来越对的语言（C++ 0x，Java 7）开始引入闭包和 Lambda 表达式的功能，编程语言似乎重新回到了函数式编程的轨道上，或许我们已经能够看到100年后的编程语言身上所应该具有的哪些特点。


### 参考

1. [高级编程语言的发展历程（六）](http://www.nowamagic.net/program/program_DevelopOfHLPL_part6.php)
2.  [闭包的概念、形式与应用](http://www.ibm.com/developerworks/cn/linux/l-cn-closure/index.html )
3.  [你的编程语言能这样做吗？](http://www.aqee.net/can-your-programming-language-do-this/)
