---
layout: post
title: Kill Assembly
category: technium
tags: []
---


汇编语言诞生于机器语言之后，高级语言之前，作为一个过渡产物它的存在是如此尴尬，以至于今天某些编译器在从源代码生成机器代码的过程中不需要生成它。


和机器语言相比，汇编语言最大的好处是程序员可以写一些符号来代替存储器地址，从而避免了手工计算偏移地址的麻烦。其次是程序员再也用不着记某条指令的操作码，除此之外汇编语言和机器代码并无本质的区别。也就是说。汇编语言仅仅是一种“更可读的”机器语言，但它的某些“设计”使得汇编器实现起来并不简单（至少没有看上去的那么简单）。


### 实现一个汇编器


最直接的想法是把汇编看成某种语言，然后为它写个编译器：

1. 词法分析
2. 语法分析，把源代码转化成一棵抽象语法树（AST）
3. 为 AST 标注属性
4. 翻译并生成目标代码


我们可以用 lex 和 yacc 这样的自动化工具，但是不得不写[冗长的 lexer 和 BNF 文件](http://ranger.uta.edu/~nystrom/courses/cse5317-sp10/project/mips.html)。况且 BNF 适合描述 Algol 系的编程语言：Pascal、C/C++、Java、Perl 或 Python，这些语言的特点是嵌套结构，而汇编语言的结构简单得多，没有这个必要。


第二种方法是用正则表达式。`/\s*(\w{2,3})\s+((\w+)(,\w+)?)?/`这个正则表达式就能匹配 2 个操作数（Op A, B）和 3 个操作数（Op A, B, C）的情况，然后根据匹配出来的模式提取操作数和操作码以便生成二进制代码，或进行错误处理。


![regex](/images/regex.png)


这种模式的语法分析器方法叫 "ad hoc"（专设）parser，比用 BNF 简单，但是还是要进行一系列判断（比如匹配出操作数后我们需要继续判断操作数是寄存器，还是立即数，或是一个 label，然后进行相应的动作）。


但是既然二进制代码之间是一对一的关系，汇编语言不过是指令的一些助记符而已，实现一个汇编器究竟需要那么复杂么？



### RTL


GCC 在设计中间语言到时候使用了一种非常接近汇编但是比汇编语言更巧妙的语言作为中间形式，这种语言叫 RTL（Register Tranfer Language）。


RTL 的语法十分像 Lisp，据说作者发明时受到了 Lisp 的启发。例如下面这段稍作简化的代码的作用是把 1 号寄存器的内容加上 2 号寄存器的内容，然后保存到 3 号寄存器中。


     (set (reg 3)
       (plus (reg 1)
         (reg 2)))


首先，这种中间语言是与目标机器无关。GCC 的前端从源代码生成 RTL，后端根据目标机器信息（如字节序、字长等）可以用 RTL 直接生成目标代码。当然这是 RTL 在设计时的目标，这一点上它和汇编语言没有可比性。


但是和汇编语言相比，它有一个很大的好处，那就是为这种语言实现 parser 是一件轻而易举的事情。因为实现一个 Lisp 语言解释器本身就很简单。前提是程序员需要这样写汇编：


    (label1
      (addi $s1, $0, -1)
      (lw, $s0, $sp, 4)
    )


而调用 addi 其实就是用这些参数生成对应的 0101……


我们甚至可以借助某种高级语言写一个“汇编文件”：


    function addi(rd, rs, rt) {
        // 生成 addi 的目标代码
    }

    addi(s0, s1, s2);    
    ...
    
    
这个文件的运行结果就是我们想要的目标文件。如果这么想，汇编这种东西是否没有存在的必要了呢？


### 符号表


为了生成符号表，普通编译器都是两遍的（即需要扫描两遍代码），第一遍生成符表，第二遍将符号表中符号所对应的地址对号入座。

    inst_loc = 0;

    add(...);       // inst_loc = 1
    add(...);       // inst_loc = 2
    label("haha");  // inst_loc = 2, symbal_table["haha"] = 2 
    add(...);       // inst_loc = 3
    jump("haha");


我们的“汇编文件”每调用一次 label() 以外的函数都会将全局变量 inst_loc 的值加 1，它表示当前指令在存储器中的位置，调用 label("haha") 的结果是在符号表中加入 haha，它对应的地址是 2，即第三条 add 的位置，执行到 jump 时，程序就会去符号表中找 haha 的地址。


另一种情况是 label 在跳转语句以后出现，这时执行 jump 语句就发现符号表中没有 haha 符号，于是就生成含有占位地址的指令，以后让连接器或加载器来负责定位。
    
 

    jump("haha");   
    add(...);       
    label("haha");
    add(...);       
    add(...);       



### 伪指令


汇编语言中有一种叫伪指令（pseudo instruction）的功能，它用来扩展现有机器的指令集。比如某些机器（如 MIPS）本身并不提供 move （寄存器移动）指令，当程序员需要实现寄存器拷贝的功能时往往需要用一条 add 指令来代替：


<span class="sidenote">注：$zero 寄存器的值始终是 0，因此 t0 = t1 + 0 = t1，相当于把 t1 中的值拷贝到了 t0 中</span>
add $t0, $zero, $t1 


这样带来的坏处显而易见，原来的“赋值”语义现在变成了“加”，程序员不但在编程时需要多绕一个弯，写出的代码也存在二义性。于是，为了让程序员在写汇编程序时更加直观，同时又不增加指令集的复杂度（因为指令集复杂度会直接影响到电路设计的复杂度），这些机器的汇编器就会提供“伪指令”，与其说是伪**指令**，不如说是给汇编器加了一道后门。不过这样的偷懒并不是没有代价的，比如 MIPS 为了实现一些伪指令，需要专门为汇编器保留一个寄存器 *。


<span class="sidenote">比如 ble $rs, $rt, label（如果 rs 小于 rt，就跳到 label）最终将替换为 slt $at, rt, $rs (如果 rt 小于 rs，at 就置 1，否则置 0)和 beq $at, $zero, label （如果 at 等于 0，就跳到 label）两条指令。</span>


现在我们可以用函数调用来实现伪指令，如 move：


    function move(rdest, rsrc) {
        add(rdest, zero, rsrc);
    }


是不是很简单？当我们调用 move() 时，“编译器”就会在背后调用 add() 生成有效的二进制代码。 


或我们可以用下面这个函数来实现 stack push 功能：


    function push(r3) {
        addi(sp, sp, -4); // 栈顶增长
        sw(r3, sp, 0);    // 寄存器的内容入栈
    }



